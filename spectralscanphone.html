<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Visual Motion Radar</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js is kept for the contact sound effect only --><script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles for the radar look */
        body {
            background-color: #0d1117; /* Dark background */
            font-family: 'Inter', sans-serif;
            color: #d1d5db;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 1rem;
        }

        #main-app-container {
            /* Max width and auto margin center the stacked layout */
            max-width: 1200px;
            width: 100%;
        }

        #radarCanvas {
            width: 100%;
            height: auto;
            border: 2px solid #10b981;
            border-bottom: none;
            border-radius: 50% 50% 0 0; /* Half-circle look */
            background: radial-gradient(circle at 50% 100%, #111827 0%, #0d1117 80%);
            box-shadow: 0 0 40px rgba(16, 185, 129, 0.5); /* Glowing green shadow */
            transition: opacity 0.5s;
        }

        /* Styling the hidden elements for processing */
        #hidden-video, #hidden-canvas {
            position: absolute;
            left: -9999px; /* Off-screen */
            opacity: 0;
            width: 160px; /* Low resolution for faster processing */
            height: 120px;
        }

        .radar-button {
            padding: 0.5rem 1.5rem;
            border-radius: 9999px;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 4px #047857;
        }
        .radar-button:active {
            box-shadow: 0 1px #047857;
            transform: translateY(3px);
        }
        
        /* New Camera Button Style */
        .camera-button {
            padding: 0.5rem 1rem;
            border-radius: 9999px;
            font-weight: 600;
            transition: all 0.2s;
            box-shadow: 0 4px #4f46e5; /* Indigo shadow */
        }
        .camera-button:active {
            box-shadow: 0 1px #4f46e5;
            transform: translateY(3px);
        }

        /* Styling for the Reset button */
        .log-reset-button {
            padding: 0.4rem 1rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s;
            box-shadow: 0 2px #92400e;
        }
        .log-reset-button:active {
            box-shadow: 0 0px #92400e;
            transform: translateY(2px);
        }

        /* Simplified status text for visual mode */
        #status-mode {
            background-color: #2563eb; 
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.75rem;
            font-weight: 700;
        }

        /* Log Entry Styling */
        .log-entry:hover {
            background-color: #1f2937; /* Darker hover */
            cursor: pointer;
        }
    </style>
</head>
<body>

    <!-- Updated container to be a single vertical column on all screen sizes -->
    <div id="main-app-container" class="flex flex-col space-y-6 p-4">

        <!-- RADAR & CONTROLS PANEL (Now at the top) -->
        <div id="radar-control-panel" class="w-full rounded-xl bg-gray-900/50 backdrop-blur-md p-6 border border-gray-700 shadow-2xl">
            <!-- Title Change -->
            <h1 class="text-3xl font-extrabold text-green-400 mb-0 tracking-wider text-center">
                Spectral Sweep
            </h1>
            <p class="text-sm text-gray-400 text-center mb-4">by PairUnNormal Degens</p>
            <!-- End Title Change -->

            <div id="status" class="text-sm text-center mb-4 p-2 rounded-lg bg-gray-800 border border-gray-700 transition-all duration-300 min-h-[40px]">
                Ready to start. Click START to begin scanning.
            </div>

            <!-- Control Buttons -->
            <div class="flex flex-wrap justify-center space-x-2 sm:space-x-4 mb-6">
                <button id="startButton" class="radar-button bg-green-500 hover:bg-green-600 text-white">
                    START RADAR
                </button>
                <button id="stopButton" class="radar-button bg-red-500 hover:bg-red-600 text-white opacity-50 cursor-not-allowed" disabled>
                    STOP RADAR
                </button>
                
                <!-- NEW: Camera Switch Button -->
                <button id="cameraSwitchButton" class="camera-button bg-indigo-500 hover:bg-indigo-600 text-white mt-2 sm:mt-0">
                    Switch Camera (Rear)
                </button>
            </div>

            <!-- Sensitivity and Timer Controls Container -->
            <div class="flex flex-col md:flex-row gap-4 mb-6">
                
                <!-- Sensitivity Control (Existing, now w-full md:w-1/2) -->
                <div class="p-3 rounded-lg bg-gray-800/70 border border-gray-700 w-full md:w-1/2">
                    <div class="flex justify-between items-center mb-1">
                        <label for="sensitivitySlider" class="text-sm font-semibold text-green-300">
                            Sensitivity
                        </label>
                        <span id="sensitivityValue" class="text-yellow-300 font-bold">300</span>
                    </div>
                    <input type="range" id="sensitivitySlider" min="50" max="1000" value="300" step="50" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer range-lg">
                    <div class="flex justify-between text-xs font-semibold text-gray-400 mt-1">
                        <span>Less (Less Motion Detected)</span>
                        <span>More (More Motion Detected)</span>
                    </div>
                </div>

                <!-- NEW: Auto-Stop Timer Control (w-full md:w-1/2) -->
                <div class="p-3 rounded-lg bg-gray-800/70 border border-gray-700 w-full md:w-1/2">
                    <div class="flex justify-between items-center mb-1">
                        <label for="autoStopMinutes" class="text-sm font-semibold text-green-300">
                            Auto-Stop Timer (Minutes)
                        </label>
                        <span id="timerValueDisplay" class="text-yellow-300 font-bold">10 min</span>
                    </div>
                    <input type="number" id="autoStopMinutes" min="1" max="180" value="10" step="1"
                           class="w-full h-10 bg-gray-700 text-white p-2 rounded-lg appearance-none text-center focus:ring-green-500 focus:border-green-500">
                    <div class="flex justify-center text-xs font-semibold text-gray-400 mt-1">
                        <span>(Set scan duration)</span>
                    </div>
                </div>

            </div>
            <!-- End Sensitivity and Timer Controls Container -->

            <!-- Radar Canvas -->
            <canvas id="radarCanvas" width="400" height="200" class="opacity-30 mx-auto block"></canvas>

            <div class="mt-4 text-xs text-gray-400 text-center">
                <p>Scanning Mode: <span id="status-mode">Visual (Motion)</span></p>
                <p class="mt-2">Motion Level Detected: <span id="visual-level" class="font-bold text-yellow-300">0</span></p>
                <p class="mt-2 text-green-400">Contacts on radar: <span id="contact-count">0</p>
                <p id="cameraStatus" class="mt-1 text-indigo-400 font-semibold">Camera: Rear (Environment)</p>
            </div>
        </div>

        <!-- CONTACT LOG PANEL (Moved to the bottom) -->
        <div id="log-panel" class="w-full rounded-xl bg-gray-900/50 backdrop-blur-md p-4 border border-gray-700 shadow-xl">
            <div class="flex justify-between items-center mb-3 border-b border-gray-700 pb-2">
                <h2 class="text-xl font-bold text-yellow-400">
                    Contact Log (Blips)
                </h2>
                <!-- NEW: Reset Log Button -->
                <button id="resetLogButton" class="log-reset-button bg-orange-600 hover:bg-orange-700 text-white text-xs">
                    RESET LOG
                </button>
            </div>

            <div id="logListContainer" class="h-64 overflow-y-auto pr-2">
                <ul id="contact-log" class="text-sm space-y-1">
                    <li class="text-gray-500">Log will appear here after startup.</li>
                </ul>
            </div>
            
            <!-- Visual Recall Area -->
            <div id="image-recall-container" class="mt-4 pt-4 border-t border-gray-700">
                <h3 class="text-lg font-semibold text-white mb-2">Visual Recall</h3>
                <img id="recallImage" class="w-full h-auto rounded-lg border border-gray-600 bg-gray-800"
                     src="https://placehold.co/160x120/1f2937/d1d5db?text=Click+a+Log+Entry" 
                     onerror="this.onerror=null; this.src='https://placehold.co/160x120/1f2937/d1d5db?text=Error';"
                     alt="Visual snapshot of the motion event">
                <p id="imageTimestamp" class="text-xs text-gray-400 mt-1 text-center"></p>
            </div>
        </div>
    </div>

    <!-- Hidden elements for media processing -->
    <video id="hidden-video" playsinline autoplay></video>
    <canvas id="hidden-canvas"></canvas>

    <script>
        // --- CONSTANTS AND GLOBAL STATE ---
        const CANVAS_WIDTH = 400;
        const CANVAS_HEIGHT = 200;
        const RADAR_RADIUS = CANVAS_WIDTH / 2;
        const CENTER_X = CANVAS_WIDTH / 2;
        const CENTER_Y = CANVAS_HEIGHT;

        // Countdown Constant
        const COUNTDOWN_SECONDS = 10; 

        // Sound Rate Limit (to prevent spamming blips)
        const BLIP_RATE_LIMIT_MS = 100; 

        // Visual Detection Thresholds
        const VISUAL_FRAME_SKIP = 3; 
        let VISUAL_MIN_MOTION_THRESHOLD = 300; 
        const VISUAL_MAX_MOTION_CAP = 2000; 
        const VISUAL_CONTACT_LIFESPAN = 3000; 
        const PIXEL_DIFF_THRESHOLD = 30; 

        // General State
        let contacts = []; // Short-lived contacts for radar display only
        let logEntries = []; // Permanent log entries for image recall (PERSISTED ON STOP)
        let sweepAngle = 0; 
        let sweepDirection = 1; 
        let frameCount = 0;
        let animationFrameId = null;

        // Media and Running State
        let mediaStream = null;
        let isRunning = false;
        let isCountingDown = false;
        // Variable to hold the current countdown value
        let countdownValue = COUNTDOWN_SECONDS; 
        let contactIDCounter = 0; 
        // Camera Facing State. 'environment' is rear, 'user' is front.
        let currentCameraFacingMode = 'environment'; 

        // TIMER GLOBALS
        let autoStopTimeoutId = null; 
        let countdownIntervalId = null;
        let scanEndTime = 0;

        // Audio Output Globals (Tone.js for sound effects)
        let mainBlipSynth = null; 
        let noiseBlip = null;
        let blipReverb = null;
        let blipDelay = null; 
        let lastBlipTime = 0; 

        // Canvas Contexts
        const canvas = document.getElementById('radarCanvas');
        const ctx = canvas.getContext('2d');
        const hiddenCanvas = document.getElementById('hidden-canvas');
        const hCtx = hiddenCanvas.getContext('2d');
        const video = document.getElementById('hidden-video');

        // Motion Detection Globals
        let lastFrameData = null;

        // UI Elements
        const statusEl = document.getElementById('status');
        const visualLevelEl = document.getElementById('visual-level');
        const contactCountEl = document.getElementById('contact-count');
        const startButton = document.getElementById('startButton');
        const stopButton = document.getElementById('stopButton');
        const contactLogEl = document.getElementById('contact-log');
        const recallImageEl = document.getElementById('recallImage');
        const imageTimestampEl = document.getElementById('imageTimestamp');
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const sensitivityValueEl = document.getElementById('sensitivityValue');
        const resetLogButton = document.getElementById('resetLogButton'); 
        const cameraSwitchButton = document.getElementById('cameraSwitchButton'); 
        const cameraStatusEl = document.getElementById('cameraStatus'); 
        
        // TIMER UI ELEMENTS
        const autoStopMinutesEl = document.getElementById('autoStopMinutes');
        const timerValueDisplayEl = document.getElementById('timerValueDisplay');


        // --- UTILITY FUNCTIONS ---

        const mapRange = (value, inMin, inMax, outMin, outMax) => {
            if (inMin === inMax) return outMin; 
            return (value - inMin) * (outMin - outMax) / (inMax - inMin) + outMax; 
        };

        /**
         * Converts polar coordinates (radius, angle in degrees) to Cartesian coordinates (x, y)
         */
        const polarToCartesian = (r, angleDeg) => {
            const angleRad = angleDeg * Math.PI / 180; 
            const x = CENTER_X + r * Math.cos(angleRad);
            const y = CENTER_Y - r * Math.sin(angleRad); 
            return { x, y };
        };

        const captureFrameAsBase64 = () => {
            const w = video.videoWidth;
            const h = video.videoHeight;

            if (w === 0 || h === 0) {
                console.warn("Capture failed: Video dimensions are zero. Returning placeholder.");
                return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNkYGD4DwAADgACxTjKAAAAAElFTkSuQmCC";
            }

            hiddenCanvas.width = w;
            hiddenCanvas.height = h;
            hCtx.drawImage(video, 0, 0, w, h);

            // --- Apply Digital Effect Filter (Simplified Grayscale to Green) ---
            const imageData = hCtx.getImageData(0, 0, w, h);
            const pixels = imageData.data;

            // Define the digital color palette
            const BRIGHT_GREEN = { r: 16, g: 185, b: 129, a: 255 }; 
            const DARK_COLOR = { r: 10, g: 20, b: 15, a: 255 };     
            const LUMINANCE_THRESHOLD = 100; 

            for (let i = 0; i < pixels.length; i += 4) {
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;

                let targetColor;
                if (luminance > LUMINANCE_THRESHOLD) {
                    targetColor = BRIGHT_GREEN;
                } else {
                    targetColor = DARK_COLOR;
                }
                
                pixels[i] = targetColor.r;
                pixels[i + 1] = targetColor.g;
                pixels[i + 2] = targetColor.b;
            }

            // Scanline Effect
            for (let y = 0; y < h; y += 2) { 
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    pixels[i] = Math.max(0, pixels[i] - 15);      
                    pixels[i + 1] = Math.max(0, pixels[i + 1] - 15); 
                    pixels[i + 2] = Math.max(0, pixels[i + 2] - 15);
                }
            }


            hCtx.putImageData(imageData, 0, 0);

            return hiddenCanvas.toDataURL('image/png');
        };

        // Exposed globally for use in HTML onclick
        window.showContactImage = (contactId) => {
            // Searches the permanent logEntries array
            const contact = logEntries.find(c => c.id === contactId); 
            if (!contact || !contact.base64Image) {
                console.error("Contact or image data not found for ID:", contactId);
                return;
            }

            // Highlight the selected log item
            document.querySelectorAll('.log-entry').forEach(el => {
                el.classList.remove('bg-green-700/50');
                el.classList.add('bg-gray-800');
            });
            const selectedLog = document.getElementById('log-' + contactId);
            if(selectedLog) {
                selectedLog.classList.remove('bg-gray-800');
                selectedLog.classList.add('bg-green-700/50');
            }

            // Display the image
            recallImageEl.src = contact.base64Image;
            const timeString = new Date(contact.detectionTime).toLocaleTimeString();
            imageTimestampEl.textContent = `Snapshot Time: ${timeString} | Angle: ${Math.round(contact.angle)}Â°`;
        };


        // --- UI CONTROL ---

        const updateUIState = () => {
            // Block buttons if running OR counting down
            const busy = isRunning || isCountingDown; 

            startButton.disabled = busy;
            // Only stop if running AND not counting down
            stopButton.disabled = !isRunning || isCountingDown; 
            
            // Allow camera switch only when not running
            cameraSwitchButton.disabled = busy;
            
            // Allow reset button only when not busy and there are logs to clear
            resetLogButton.disabled = busy || logEntries.length === 0;

            // Disable timer input
            autoStopMinutesEl.disabled = busy;
            autoStopMinutesEl.classList.toggle('opacity-50', busy);

            startButton.classList.toggle('opacity-50', busy);
            startButton.classList.toggle('cursor-not-allowed', busy);
            stopButton.classList.toggle('opacity-50', !isRunning || isCountingDown);
            stopButton.classList.toggle('cursor-not-allowed', !isRunning || isCountingDown);
            cameraSwitchButton.classList.toggle('opacity-50', busy);
            cameraSwitchButton.classList.toggle('cursor-not-allowed', busy);


            canvas.style.opacity = isRunning ? '1.0' : '0.3';
            updateCameraStatusUI(); 
            updateStatusMessage();
        };

        const updateCameraStatusUI = () => {
             const isRear = currentCameraFacingMode === 'environment';
             cameraSwitchButton.textContent = `Switch Camera (${isRear ? 'Front' : 'Rear'})`;
             cameraStatusEl.textContent = `Camera: ${isRear ? 'Rear (Environment)' : 'Front (User)'}`;
        };
        
        // Function to update the remaining scan time display
        const updateScanTimer = () => {
            if (!isRunning && !isCountingDown) return;

            const remainingMs = scanEndTime - Date.now();

            if (remainingMs <= 0) {
                // If the interval runs out before the final timeout (shouldn't happen), stop it
                clearInterval(countdownIntervalId);
                return;
            }

            const totalSeconds = Math.floor(remainingMs / 1000);
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            const timeString = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            if (isRunning) {
                // Update the status bar with the remaining time
                statusEl.innerHTML = `Radar Active. Scanning for motion. <span class="text-yellow-300 ml-2 font-bold">TIME REMAINING: ${timeString}</span>`;
            } else if (isCountingDown) {
                // Update the countdown value for the canvas overlay
                countdownValue = totalSeconds - (minutes * 60);
            }
        };

        const updateStatusMessage = () => {
            if (isCountingDown) {
                // Status message should reflect the pre-start phase, but the count is on canvas
                statusEl.innerHTML = `<span class="text-yellow-400 font-bold">RADAR ACTIVATION PENDING...</span>`;
            } else if (!isRunning) {
                statusEl.textContent = `Radar Stopped. ${logEntries.length > 0 ? 'Reviewing log entries...' : 'Log is clear.'}`;
            } else {
                // When running, the status is handled by updateScanTimer
            }
        };

        // --- SOUND GENERATION (Creepy Blip Effect with Echo) ---

        const initializeBlipSynth = () => {
            // 1. Delay (Echo) effect
            blipDelay = new Tone.FeedbackDelay({
                delayTime: 0.25, 
                feedback: 0.6,  
                wet: 0.7        
            });

            // 2. Reverb effect (ghostly wash)
            blipReverb = new Tone.Reverb({
                decay: 4, 
                preDelay: 0.05,
                wet: 0.6 
            }).toDestination();
            
            blipDelay.connect(blipReverb);
            
            // 3. Main unsettling tone (low, detuned square wave)
            mainBlipSynth = new Tone.Synth({
                oscillator: { type: 'square', detune: 10 }, 
                envelope: {
                    attack: 0.01,
                    decay: 1.0, 
                    sustain: 0.05,
                    release: 1.5 
                },
                filter: {
                    Q: 2,
                    type: 'lowpass',
                    frequency: 1000 
                }
            }).connect(blipDelay); 

            // 4. Static/sizzle component
            noiseBlip = new Tone.NoiseSynth({
                noise: { type: 'pink' },
                envelope: {
                    attack: 0.001,
                    decay: 0.15, 
                    sustain: 0,
                    release: 0.5
                }
            }).connect(blipDelay); 
            
            // Set volumes
            mainBlipSynth.volume.value = -15; 
            noiseBlip.volume.value = -20;
        };

        const playBlip = () => {
            if (!mainBlipSynth || !noiseBlip || Tone.context.state !== 'running') return;
            
            const now = Date.now();
            if (now - lastBlipTime < BLIP_RATE_LIMIT_MS) {
                return; 
            }
            lastBlipTime = now; 

            mainBlipSynth.triggerAttackRelease('C3', "4n");
            noiseBlip.triggerAttackRelease("16n", Tone.context.currentTime + 0.01);
        };

        // --- VIDEO PROCESSING (MOTION DETECTION) ---

        const processVideo = () => {
            if (video.readyState !== video.HAVE_ENOUGH_DATA || !isRunning) {
                visualLevelEl.textContent = 0;
                return 0;
            }
            if (!hCtx) return 0;

            frameCount++;
            if (frameCount % VISUAL_FRAME_SKIP !== 0) return 0;

            const w = video.videoWidth;
            const h = video.videoHeight;

            if (w === 0 || h === 0) return 0;

            hiddenCanvas.width = w;
            hiddenCanvas.height = h;
            hCtx.drawImage(video, 0, 0, w, h);
            const currentFrameData = hCtx.getImageData(0, 0, w, h);
            const currentPixels = currentFrameData.data;

            if (!lastFrameData) {
                lastFrameData = currentPixels.slice();
                return 0;
            }

            let motionMagnitude = 0;
            let motionXSum = 0;
            let motionCount = 0;

            for (let i = 0; i < currentPixels.length; i += 4) {
                const diff = Math.abs(currentPixels[i] - lastFrameData[i]) +
                             Math.abs(currentPixels[i + 1] - lastFrameData[i + 1]) +
                             Math.abs(currentPixels[i + 2] - lastFrameData[i + 2]);

                if (diff > PIXEL_DIFF_THRESHOLD * 3) { 
                    motionMagnitude++;
                    const pixelIndex = i / 4;
                    const pixelX = pixelIndex % w;
                    motionXSum += pixelX;
                    motionCount++;
                }
            }

            lastFrameData = currentPixels.slice();
            visualLevelEl.textContent = motionMagnitude;

            if (motionMagnitude > VISUAL_MIN_MOTION_THRESHOLD) {
                const clampedMotion = Math.min(motionMagnitude, VISUAL_MAX_MOTION_CAP);

                const distanceR = mapRange(
                    clampedMotion,
                    VISUAL_MIN_MOTION_THRESHOLD,
                    VISUAL_MAX_MOTION_CAP,
                    RADAR_RADIUS * 0.1, 
                    RADAR_RADIUS 
                );
                
                const avgX = motionCount > 0 ? motionXSum / motionCount : w / 2;
                const angle = mapRange(avgX, 0, w, 180, 0); 
                
                const base64Image = captureFrameAsBase64();

                addContact({
                    type: 'Visual',
                    motion: motionMagnitude,
                    r: distanceR,
                    angle: angle,
                    life: Date.now() + VISUAL_CONTACT_LIFESPAN,
                    base64Image: base64Image,
                    detectionTime: Date.now()
                });
                
                playBlip();
            }

            return motionMagnitude;
        };

        // --- CONTACT MANAGEMENT ---

        const addContact = (newContact) => {
            newContact.id = contactIDCounter++;

            // 1. Store the full contact data permanently for log recall
            logEntries.push(newContact);

            // Simple logic to debounce/smooth contacts near the same area (for RADAR DOTS)
            const existing = contacts.find(c => {
                const angleDiff = Math.abs(c.angle - newContact.angle);
                const rDiff = Math.abs(c.r - newContact.r);
                return angleDiff < 15 && rDiff < RADAR_RADIUS * 0.2 && (Date.now() - c.detectionTime < 500); 
            });

            if (existing) {
                existing.life = newContact.life;
                existing.r = (existing.r * 0.8) + (newContact.r * 0.2);
                existing.angle = (existing.angle * 0.8) + (newContact.angle * 0.2);
            } else {
                // 2. Only push to the temporary 'contacts' array if it's a new visible blip
                contacts.push(newContact);
            }
            logContact(newContact); // Add to the visual log UI
            contactCountEl.textContent = contacts.length;
        };
        
        const logContact = (contact) => {
            const timeString = new Date(contact.detectionTime).toLocaleTimeString();
            const angleRounded = Math.round(contact.angle);
            const rString = contact.r > RADAR_RADIUS * 0.5 ? 'Far' : 'Close';

            const li = document.createElement('li');
            li.id = `log-${contact.id}`;
            li.className = 'log-entry p-2 rounded-lg bg-gray-800 text-green-300 transition-colors duration-150 flex justify-between items-center';
            li.setAttribute('onclick', `window.showContactImage(${contact.id})`);
            
            li.innerHTML = `
                <div>
                    <span class="font-bold">Contact ${contact.id}</span>
                    <span class="text-xs text-gray-400 ml-2">(${rString}, ${angleRounded}Â°)</span>
                </div>
                <span class="text-xs text-yellow-300">${timeString}</span>
            `;

            if (contactLogEl.firstElementChild && contactLogEl.firstElementChild.className.includes('text-gray-500')) {
                contactLogEl.innerHTML = ''; 
            }
            contactLogEl.prepend(li);
            updateUIState(); // Ensure the reset button is enabled if a log item exists
        };


        // --- CANVAS RENDERING ---

        const drawGrid = () => {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            ctx.save();
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, RADAR_RADIUS, Math.PI, 0, false);
            ctx.clip();

            // 1. Draw Grid Lines (Distance Rings)
            ctx.strokeStyle = '#10b98144'; 
            ctx.lineWidth = 1;
            for (let i = 1; i <= 4; i++) {
                const r = i * (RADAR_RADIUS / 4);
                ctx.beginPath();
                ctx.arc(CENTER_X, CENTER_Y, r, Math.PI, 0, false);
                ctx.stroke();
            }

            // 2. Draw Radial Lines (Angle)
            for (let deg = 0; deg <= 180; deg += 15) {
                const { x, y } = polarToCartesian(RADAR_RADIUS, deg);
                ctx.beginPath();
                ctx.moveTo(CENTER_X, CENTER_Y);
                ctx.lineTo(x, y);
                ctx.stroke();

                // Draw Angle Markers
                if (deg % 30 === 0) { 
                    ctx.fillStyle = '#10b981';
                    ctx.font = '10px Inter';
                    
                    if (deg === 0) ctx.textAlign = 'left';
                    else if (deg === 180) ctx.textAlign = 'right';
                    else ctx.textAlign = 'center';

                    const markerR = RADAR_RADIUS + 10;
                    const markerPos = polarToCartesian(markerR, deg);
                    ctx.fillText(deg + 'Â°', markerPos.x, markerPos.y);
                }
            }

            ctx.restore(); 
        };

        const drawSweep = () => {
            const currentAngle = sweepAngle * 180 / Math.PI;
            const { x, y } = polarToCartesian(RADAR_RADIUS, currentAngle);

            // Draw the sweep line
            ctx.beginPath();
            ctx.moveTo(CENTER_X, CENTER_Y);
            ctx.lineTo(x, y);
            ctx.lineWidth = 3;
            ctx.strokeStyle = '#34d399'; 
            ctx.stroke();

            // Create a gradient for the "afterglow" effect
            const gradient = ctx.createRadialGradient(CENTER_X, CENTER_Y, 0, CENTER_X, CENTER_Y, RADAR_RADIUS);
            gradient.addColorStop(0, 'rgba(16, 185, 129, 0)');
            gradient.addColorStop(0.5, 'rgba(16, 185, 129, 0.05)');
            gradient.addColorStop(1, 'rgba(16, 185, 129, 0.2)');

            // Apply gradient as a filled arc section (simulating persistence)
            ctx.globalAlpha = 0.5;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, RADAR_RADIUS, sweepAngle - 0.1, sweepAngle, false); 
            ctx.lineTo(CENTER_X, CENTER_Y);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        };

        const drawContacts = () => {
            const now = Date.now();
            const sweepAngleDeg = sweepAngle * 180 / Math.PI;

            // Filter out expired contacts (for visual dots on the radar only)
            contacts = contacts.filter(c => c.life > now);

            contacts.forEach(c => {
                const { x, y } = polarToCartesian(c.r, c.angle);

                let distToSweep = Math.abs(c.angle - sweepAngleDeg);
                const isSwept = distToSweep < 5; 

                ctx.beginPath();
                ctx.arc(x, y, 6, 0, 2 * Math.PI);

                ctx.fillStyle = isSwept ? '#fcd34d' : '#fcd34d77'; 
                ctx.shadowColor = isSwept ? '#fcd34d' : 'transparent';
                
                ctx.shadowBlur = isSwept ? 10 : 0;
                ctx.fill();
            });

            ctx.shadowBlur = 0; 
            contactCountEl.textContent = contacts.length;
        };
        
        /**
         * Draws the large, central countdown text on the radar.
         */
        const drawCountdownOverlay = () => {
            if (!isCountingDown) return;

            // Set text style for the countdown
            ctx.save();
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font = 'bold 80px Inter, sans-serif';
            
            // Text color and shadow
            ctx.fillStyle = `rgba(252, 211, 77, 1.0)`; // Bright yellow
            ctx.strokeStyle = `rgba(16, 185, 129, 0.8)`; // Green outline
            ctx.lineWidth = 4;
            ctx.shadowColor = `rgba(252, 211, 77, 0.5)`;
            ctx.shadowBlur = 10;
            
            // Text to display
            const text = String(countdownValue);

            // Coordinates (centered slightly above the bottom line for visibility)
            const x = CENTER_X;
            const y = CENTER_Y - (CANVAS_HEIGHT * 0.3); // About 70% up from the bottom

            // Draw shadow, stroke, and fill
            ctx.strokeText(text, x, y);
            ctx.fillText(text, x, y);

            // Draw supporting text
            ctx.font = 'bold 16px Inter, sans-serif';
            ctx.fillStyle = `rgba(144, 238, 144, 0.8)`; // Pale green
            ctx.fillText('ACTIVATION', x, y + 50);

            ctx.restore();
        };


        // --- MAIN ANIMATION LOOP ---

        const animate = () => {
            // FIX: Removed the early exit condition 'if (!isRunning && !isCountingDown) return;'.
            // The loop must now run continuously from startRadar until stopRadar is called, 
            // ensuring the sweep and countdown are drawn during the transition phase.

            // 1. Input Processing (only if running)
            if (isRunning) {
                processVideo();
            }

            // 2. Clear and Draw Grid
            drawGrid();

            // 3. Draw Contacts (only if running)
            if (isRunning) {
                drawContacts();
            }

            // 4. Draw Sweep (always draw for visual effect)
            drawSweep();
            
            // 5. Draw Countdown Overlay (if counting down)
            if (isCountingDown) {
                drawCountdownOverlay();
            }


            // 6. Update Sweep Angle 
            sweepAngle += 0.02 * sweepDirection;

            // Boundary checks and direction flip (0 to PI)
            if (sweepDirection === 1 && sweepAngle >= Math.PI) {
                sweepDirection = -1; 
                sweepAngle = Math.PI; 
            } else if (sweepDirection === -1 && sweepAngle <= 0) {
                sweepDirection = 1; 
                sweepAngle = 0; 
            }

            animationFrameId = requestAnimationFrame(animate);
        };

        // --- CORE RADAR INITIALIZATION (Runs AFTER countdown) ---

        // Added facingMode parameter to request the specific camera
        const initRadarCore = async (facingMode) => {
            if (isRunning) return;

            statusEl.textContent = 'Requesting camera permission...';

            try {
                // 1. Request Media Stream (Video ONLY) with facing mode constraint
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 160,
                        height: 120,
                        frameRate: 30,
                        // Use the facing mode constraint
                        facingMode: facingMode 
                    },
                    audio: false 
                });

                mediaStream = stream; 
                isRunning = true;
                currentCameraFacingMode = facingMode; // Update state on successful access
                updateUIState(); 
                updateScanTimer(); // Initial call to show remaining time

                // 2. Initialize Tone.js
                if (Tone.context.state !== 'running') {
                    await Tone.start();
                }
                
                // 3. Initialize Blip Synth 
                initializeBlipSynth();

                // 4. Set up video stream
                video.srcObject = stream;
                
                // 5. Start the drawing/analysis loop once video is ready
                const startAnimation = async () => { 
                    if (animationFrameId === null) {
                         await video.play().catch(e => console.error("Video Playback Error:", e)); 
                         updateStatusMessage(); 
                         // Check if animation is already running before calling it again
                         // The overall animate loop is running, so we only need to ensure isRunning is true.
                         // No need to call animate() here if it was already called by startRadar.
                    }
                };

                // Wait for the video metadata to load before attempting to start the animation/play
                if (video.readyState >= 1) { 
                    startAnimation();
                } else {
                    video.onloadedmetadata = startAnimation;
                }

            } catch (err) {
                console.error("Error accessing media devices: ", err);
                isRunning = false;
                updateUIState();
                statusEl.innerHTML = `
                    <p class="text-red-400">ðŸš¨ Access Denied! Please grant camera permission to run the radar.</p>
                    <p class="text-xs text-red-300 mt-1">Error: ${err.name}</p>
                `;
            }
        };

        // --- CAMERA CONTROL FUNCTIONS ---

        const switchCamera = () => {
             if (isRunning || isCountingDown) {
                 statusEl.innerHTML = '<span class="text-red-400 font-bold">Cannot switch camera while radar is running or counting down.</span>';
                 return;
             }
             // Toggle the state
             currentCameraFacingMode = currentCameraFacingMode === 'environment' ? 'user' : 'environment';
             updateCameraStatusUI();
             statusEl.textContent = `Camera switched to ${currentCameraFacingMode === 'environment' ? 'Rear (Environment)' : 'Front (User)'}. Click START to scan.`;
        };

        // --- CONTROL FUNCTIONS ---
        
        const startRadar = () => {
            if (isRunning || isCountingDown) return;

            // --- TIMER LOGIC START: Setup the auto-stop timeout and visual interval ---
            const durationMinutes = parseInt(autoStopMinutesEl.value);
            if (isNaN(durationMinutes) || durationMinutes < 1) {
                autoStopMinutesEl.value = 10;
                statusEl.innerHTML = `<span class="text-red-400 font-bold">Invalid time set. Defaulting to 10 minutes.</span>`;
                return;
            }

            const scanDurationMs = durationMinutes * 60 * 1000;
            const totalDelay = scanDurationMs + (COUNTDOWN_SECONDS * 1000); // Scan duration + initial 10s countdown

            scanEndTime = Date.now() + totalDelay;
            countdownValue = COUNTDOWN_SECONDS; // Initialize the visual countdown value

            // 1. Set the main timeout to automatically stop the radar
            autoStopTimeoutId = setTimeout(() => {
                stopRadar(true); // true means auto-stopped
            }, totalDelay); 

            // 2. Start the visual countdown/timer interval (runs every second)
            countdownIntervalId = setInterval(updateScanTimer, 1000);
            
            // --- Immediately start animation for countdown overlay and sweep ---
            if (animationFrameId === null) {
                animate();
            }
            // --- TIMER LOGIC END ---


            isCountingDown = true;
            updateUIState();
            
            // Update the text status bar, but the count is on the canvas
            statusEl.innerHTML = `<span class="text-yellow-400 font-bold">RADAR ACTIVATION PENDING...</span>`;


            const countdownInterval = setInterval(() => {
                // The countdownValue is updated by updateScanTimer()
                if (countdownValue <= 0) {
                    clearInterval(countdownInterval);
                    isCountingDown = false;
                    updateUIState(); 
                    // Pass the selected camera mode to the core initializer
                    initRadarCore(currentCameraFacingMode); 
                }
            }, 1000);
        };

        const stopRadar = (isAutoStop = false) => {
            if (!isRunning && !isCountingDown) return;

            // Stop the animation loop
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null; 
            }
            
            isRunning = false;
            isCountingDown = false;
            countdownValue = COUNTDOWN_SECONDS; // Reset countdown value

            // --- TIMER LOGIC: Clear all running timers ---
            clearTimeout(autoStopTimeoutId);
            clearInterval(countdownIntervalId);
            autoStopTimeoutId = null;
            countdownIntervalId = null;
            
            if (mediaStream) {
                mediaStream.getTracks().forEach(track => track.stop());
                mediaStream = null;
            }
            
            // Dispose of the audio elements
            if (mainBlipSynth) {
                mainBlipSynth.dispose();
                mainBlipSynth = null;
            }
            if (noiseBlip) {
                noiseBlip.dispose();
                noiseBlip = null;
            }
            if (blipDelay) {
                blipDelay.dispose();
                blipDelay = null;
            }
            if (blipReverb) {
                blipReverb.dispose();
                blipReverb = null;
            }

            drawGrid(); 
            contacts = []; // Clear temporary visual dots only

            visualLevelEl.textContent = 0;
            contactCountEl.textContent = 0; // The radar itself shows 0 contacts once stopped/cleared
            lastBlipTime = 0; 

            imageTimestampEl.textContent = "Click a log entry to view the snapshot.";

            if (isAutoStop) {
                 statusEl.innerHTML = '<span class="text-red-400 font-bold">RADAR STOPPED: Scan duration complete.</span>';
            } else {
                 updateStatusMessage(); 
            }
            updateUIState();

            // Rerun drawGrid one last time to clear any residual effects after stopping animation
            drawGrid();
        };

        // Function to reset the log and state
        const resetLog = () => {
            if (isRunning || isCountingDown) return;

            logEntries = []; // Clear permanent log data
            
            // Clear the visual recall image
            recallImageEl.src = "https://placehold.co/160x120/1f2937/d1d5db?text=Click+a+Log+Entry";
            imageTimestampEl.textContent = "";

            // Clear the visual log list
            contactLogEl.innerHTML = '<li class="text-gray-500">Log will appear here after startup.</li>';

            // Reset the counter
            contactIDCounter = 0; 
            
            updateUIState();
        };


        // --- INITIALIZATION ---

        const init = () => {
            canvas.width = CANVAS_WIDTH;
            canvas.height = CANVAS_HEIGHT;

            drawGrid();

            startButton.addEventListener('click', startRadar);
            stopButton.addEventListener('click', stopRadar);
            resetLogButton.addEventListener('click', resetLog); 
            cameraSwitchButton.addEventListener('click', switchCamera); 

            // Initialize and listen to the Sensitivity Slider
            VISUAL_MIN_MOTION_THRESHOLD = parseInt(sensitivitySlider.value);
            sensitivityValueEl.textContent = VISUAL_MIN_MOTION_THRESHOLD;

            sensitivitySlider.addEventListener('input', (e) => {
                VISUAL_MIN_MOTION_THRESHOLD = parseInt(e.target.value);
                sensitivityValueEl.textContent = VISUAL_MIN_MOTION_THRESHOLD;
            });
            
            // Initialize and listen to the Auto-Stop Timer Input
            timerValueDisplayEl.textContent = `${autoStopMinutesEl.value} min`;
            autoStopMinutesEl.addEventListener('input', (e) => {
                const val = parseInt(e.target.value) || 0;
                // Clamp value to min 1 and max 180 for safety
                const clampedVal = Math.min(Math.max(val, 1), 180); 
                e.target.value = clampedVal;
                timerValueDisplayEl.textContent = `${clampedVal} min`;
            });

            updateUIState();
        }

        window.onload = init;
    </script>
</body>
</html>